
/*******************************************************************************
    Verilog netlist generated by IPGEN Lattice Radiant Software (64-bit)
    2024.2.0.3.0
    Soft IP Version: 1.4.0
    2025 03 28 08:16:44
*******************************************************************************/
/*******************************************************************************
    Wrapper Module generated per user settings.
*******************************************************************************/
(* ORIG_MODULE_NAME="image_bram", LATTICE_IP_GENERATED="1" *) module image_bram (rd_clk_i, 
        rd_en_i, 
        rd_clk_en_i, 
        rd_addr_i, 
        rd_data_o) ;
    input rd_clk_i ; 
    input rd_en_i ; 
    input rd_clk_en_i ; 
    input [10:0] rd_addr_i ; 
    output [7:0] rd_data_o ; 
    image_bram_ipgen_lscc_distributed_rom #(.FAMILY("LIFCL"),
            .RADDR_DEPTH(1536),
            .RDATA_WIDTH(8),
            .REGMODE("noreg"),
            .RESETMODE("sync"),
            .RADDR_WIDTH(11),
            .INIT_MODE("mem_file"),
            .INIT_FILE("C:/Users/zenop/OneDrive/Documents/Lattice-Radiant-FPGA-IDE/Adiuvo_BCard_proj/image_bram/misc/lattice_bram_image_data_image_bram_copy.mem"),
            .INIT_FILE_FORMAT("hex")) lscc_distributed_rom_inst (.rd_clk_i(rd_clk_i), 
                .rst_i(1'b0), 
                .rd_en_i(rd_en_i), 
                .rd_clk_en_i(rd_clk_en_i), 
                .rd_addr_i(rd_addr_i[10:0]), 
                .rd_data_o(rd_data_o[7:0])) ; 
endmodule



// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2023 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               : Radiant Software 1.2
// File                  : lscc_distributed_rom.v
// Title                 :
// Dependencies          :
// Description           : Implements a ROM using distributed memory.
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             :
// Mod. Date             :
// Changes Made          : Initial release.
// =============================================================================
module image_bram_ipgen_lscc_distributed_rom #(parameter RADDR_DEPTH = 512, 
        parameter RADDR_WIDTH = clog2(RADDR_DEPTH), 
        parameter RDATA_WIDTH = 36, 
        parameter REGMODE = "reg", 
        parameter GSR = "", 
        parameter RESETMODE = "sync", 
        parameter INIT_FILE = "none", 
        parameter INIT_FILE_FORMAT = "binary", 
        parameter FAMILY = "iCE40UP", 
        parameter MODULE_TYPE = "lscc_distributed_rom", 
        parameter INIT_MODE = "none", 
        parameter ECC_ENABLE = "") (
    // -----------------------------------------------------------------------------
    // Input/Output Ports
    // -----------------------------------------------------------------------------
    input rd_clk_i, 
    input rst_i, 
    input rd_clk_en_i, 
    input rd_en_i, 
    input [(RADDR_WIDTH - 1):0] rd_addr_i, 
    output reg [(RDATA_WIDTH - 1):0] rd_data_o) ;
    // -----------------------------------------------------------------------------
    // Local Parameters
    // -----------------------------------------------------------------------------
    wire rd_en ; 
    // -----------------------------------------------------------------------------
    // Register Declarations
    // -----------------------------------------------------------------------------
    (* syn_romstyle="logic" *) reg [(RDATA_WIDTH - 1):0] mem [((2 ** RADDR_WIDTH) - 1):0] ; 
    // -----------------------------------------------------------------------------
    // Assign Statements
    // -----------------------------------------------------------------------------
    assign rd_en = (rd_en_i & rd_clk_en_i) ; 
    // -----------------------------------------------------------------------------
    // Initial Block
    // -----------------------------------------------------------------------------
    integer j ; 
    initial
        begin
            if (((INIT_MODE == "mem_file") && (INIT_FILE != "none"))) 
                begin
                    if ((INIT_FILE_FORMAT == "hex")) 
                        begin
                            $readmemh (INIT_FILE,
                                    mem,
                                    0,
                                    (RADDR_DEPTH - 1)) ;
                        end
                    else
                        begin
                            $readmemb (INIT_FILE,
                                    mem,
                                    0,
                                    (RADDR_DEPTH - 1)) ;
                        end
                end
        end
    // -----------------------------------------------------------------------------
    // Generate Sequential Blocks
    // -----------------------------------------------------------------------------
    if ((REGMODE == "noreg")) 
        begin : genblk1
            always
                @(*)
                begin
                    rd_data_o = mem[rd_addr_i] ;
                end
        end
    else
        begin : genblk1
            reg [(RDATA_WIDTH - 1):0] dataout_reg ; 
            always
                @(*)
                begin
                    dataout_reg = mem[rd_addr_i] ;
                end
            if ((RESETMODE == "sync")) 
                begin : genblk1
                    always
                        @(posedge rd_clk_i)
                        begin
                            if (rst_i) 
                                begin
                                    rd_data_o <=  'h0 ;
                                end
                            else
                                if (rd_en) 
                                    begin
                                        rd_data_o <=  dataout_reg ;
                                    end
                        end
                end
            else
                begin : genblk1
                    always
                        @(posedge rd_clk_i or 
                            posedge rst_i)
                        begin
                            if (rst_i) 
                                begin
                                    rd_data_o <=  'h0 ;
                                end
                            else
                                if (rd_en) 
                                    begin
                                        rd_data_o <=  dataout_reg ;
                                    end
                        end
                end
        end
    //------------------------------------------------------------------------------
    // Function Definition
    //------------------------------------------------------------------------------
    function [31:0] clog2 ; 
        input [31:0] value ; 
        reg [31:0] num ; 
        begin
            num = (value - 1) ;
            for (clog2 = 0 ; (num > 0) ; clog2 = (clog2 + 1))
                num = (num >> 1) ;
        end
    endfunction
endmodule


